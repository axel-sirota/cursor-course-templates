---
description: Session-based test-driven development patterns for E2E and unit tests
globs: ["tests/**", "**/*test*.py", "plan/sessions/**"]
alwaysApply: false
---

# Session-Based Testing First: Test-Driven Development

## Purpose
Enforce strict test-driven development within each session where E2E tests are written before implementation, tests drive design decisions, and all tests must pass before session completion.

## Session TDD Core Principle

RED → GREEN → REFACTOR (per session)

1. RED: Write test that fails (at session start)
2. GREEN: Implement minimum code to pass test (during session)
3. REFACTOR: Improve code while keeping tests green (before session end)

## Session Testing Context

Each session follows TDD principles:
- Session N: Write E2E tests for current endpoint
- Session N: Implement endpoint to make tests pass
- Session N: Refactor while keeping tests green
- Session N: Document test results in session summary

## E2E Testing Patterns

### Test Structure
Every endpoint test follows this structure:

```python
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_endpoint_success_case():
    """Test successful endpoint execution"""
    # Arrange: Setup test data
    # Act: Make request
    # Assert: Verify response
    pass

def test_endpoint_error_case():
    """Test error handling"""
    pass

def test_endpoint_validation():
    """Test input validation"""
    pass

def test_endpoint_authentication():
    """Test authentication requirements"""
    pass
```

### Using Skeleton Mock Data
Phase 0 skeleton provides expected output structure.

**Step 1: Capture mock response**
```python
# From Phase 0 skeleton
POST /resources returns:
{
    "resourceId": "mock-123",
    "name": "Mock Resource",
    "description": "Mock description",
    "ownerId": "mock-owner",
    "createdAt": "2024-01-01T00:00:00Z"
}
```

**Step 2: Write test using structure**
```python
def test_create_resource():
    """Session 2: Phase 1 - Create resource with real implementation"""
    response = client.post("/api/resources", json={
        "name": "Test Resource",
        "description": "Test description",
        "ownerId": "test-owner-123"
    }, headers={"Authorization": f"Bearer {test_token}"})
    
    # Verify structure matches skeleton
    assert response.status_code == 200
    data = response.json()
    
    # Check all fields present
    assert "resourceId" in data
    assert "name" in data
    assert "description" in data
    assert "ownerId" in data
    assert "createdAt" in data
    
    # Verify data correctness
    assert data["name"] == "Test Resource"
    assert data["description"] == "Test description"
    
    # Verify dynamic fields
    assert data["resourceId"] != "mock-123"  # Should be real ID
    assert data["createdAt"] != "2024-01-01T00:00:00Z"  # Should be actual timestamp
```

### Test Fixtures
Create reusable test fixtures in conftest.py:

```python
import pytest
from fastapi.testclient import TestClient
from app.main import app

@pytest.fixture
def client():
    """Test client fixture"""
    return TestClient(app)

@pytest.fixture
def auth_token():
    """Authentication token fixture"""
    # Create test user and get token
    response = client.post("/api/auth/register", json={
        "email": f"test-{uuid.uuid4()}@example.com",
        "password": "testpass123",
        "fullName": "Test User"
    })
    return response.json()["accessToken"]

@pytest.fixture
def auth_headers(auth_token):
    """Authorization headers fixture"""
    return {"Authorization": f"Bearer {auth_token}"}

@pytest.fixture
def test_resource(client, auth_headers):
    """Create a test resource fixture"""
    response = client.post("/api/resources", json={
        "name": "Test Resource",
        "description": "Test description",
        "ownerId": "test-owner"
    }, headers=auth_headers)
    return response.json()
```

### Testing Patterns by HTTP Method

**POST Endpoints:**
```python
def test_create_resource(client, auth_headers):
    """Test resource creation"""
    response = client.post("/api/resources", json={
        "name": "New Resource",
        "description": "Description"
    }, headers=auth_headers)
    
    assert response.status_code == 200
    data = response.json()
    assert data["resourceId"] is not None
    assert data["name"] == "New Resource"

def test_create_resource_validation(client, auth_headers):
    """Test validation errors"""
    response = client.post("/api/resources", json={
        "name": ""  # Invalid: empty name
    }, headers=auth_headers)
    
    assert response.status_code == 422
    
def test_create_resource_unauthorized(client):
    """Test authentication requirement"""
    response = client.post("/api/resources", json={
        "name": "Resource"
    })
    
    assert response.status_code == 401
```

**GET Endpoints:**
```python
def test_get_resource(client, auth_headers, test_resource):
    """Test resource retrieval"""
    resource_id = test_resource["resourceId"]
    response = client.get(f"/api/resources/{resource_id}", headers=auth_headers)
    
    assert response.status_code == 200
    data = response.json()
    assert data["resourceId"] == resource_id

def test_get_resource_not_found(client, auth_headers):
    """Test 404 error"""
    response = client.get("/api/resources/nonexistent", headers=auth_headers)
    assert response.status_code == 404
```

**PUT/PATCH Endpoints:**
```python
def test_update_resource(client, auth_headers, test_resource):
    """Test resource update"""
    resource_id = test_resource["resourceId"]
    response = client.put(f"/api/resources/{resource_id}", json={
        "name": "Updated Name"
    }, headers=auth_headers)
    
    assert response.status_code == 200
    data = response.json()
    assert data["name"] == "Updated Name"
```

**DELETE Endpoints:**
```python
def test_delete_resource(client, auth_headers, test_resource):
    """Test resource deletion"""
    resource_id = test_resource["resourceId"]
    response = client.delete(f"/api/resources/{resource_id}", headers=auth_headers)
    
    assert response.status_code == 204
    
    # Verify deletion
    get_response = client.get(f"/api/resources/{resource_id}", headers=auth_headers)
    assert get_response.status_code == 404
```

## Unit Testing Patterns

Unit tests are written AFTER E2E tests pass.

### Service Layer Tests
Mock repositories to test business logic:

```python
from unittest.mock import Mock, AsyncMock
import pytest
from app.modules.resources.services.resource_service import ResourceService
from app.modules.resources.models import Resource, ResourceCreate

class TestResourceService:
    def setup_method(self):
        """Setup test fixtures"""
        self.mock_repo = Mock()
        self.mock_repo.create = AsyncMock()
        self.service = ResourceService(db=Mock())
        self.service.resource_repo = self.mock_repo
    
    @pytest.mark.asyncio
    async def test_create_resource_success(self):
        """Test successful resource creation"""
        # Arrange
        resource_data = ResourceCreate(
            name="Test",
            description="Description",
            owner_id="owner-123"
        )
        expected_resource = Resource(
            id="resource-123",
            name="Test",
            description="Description",
            owner_id="owner-123",
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        self.mock_repo.create.return_value = expected_resource
        
        # Act
        result = await self.service.create_resource(resource_data)
        
        # Assert
        assert result.id == "resource-123"
        assert result.name == "Test"
        self.mock_repo.create.assert_called_once_with(resource_data)
    
    @pytest.mark.asyncio
    async def test_create_resource_repository_error(self):
        """Test error handling"""
        resource_data = ResourceCreate(name="Test", description="Description", owner_id="owner-123")
        self.mock_repo.create.side_effect = Exception("Database error")
        
        with pytest.raises(Exception, match="Database error"):
            await self.service.create_resource(resource_data)
```

## Test Organization

```
tests/
├── api/                    # E2E tests for API endpoints
│   ├── test_health.py
│   ├── test_auth.py
│   └── test_resources.py
├── modules/                # Unit tests for business logic
│   └── resources/
│       ├── test_resource_service.py
│       └── test_resource_models.py
└── conftest.py            # Shared fixtures
```

## Session Test Execution Strategy

### Session Development (TDD Cycle)
```bash
# Run specific test while implementing in current session
pytest tests/api/test_resources.py::test_create_resource -v

# Watch mode (if using pytest-watch)
ptw tests/api/test_resources.py
```

### Session Completion
```bash
# Run all E2E tests for current session
pytest tests/api/test_resources.py -v

# Run all tests to ensure no regressions
pytest tests/ -v

# Run with coverage for session
pytest tests/ --cov=app --cov-report=html
```

## Test Data Management

### Database State
For E2E tests using real database:
- Use unique identifiers (UUID) to avoid conflicts
- Clean up test data in fixtures if needed
- Consider using test database separate from development

### Mock Data Consistency
Use consistent patterns:
```python
# Test IDs
TEST_USER_ID = "test-user-123"
TEST_RESOURCE_ID = "test-resource-456"
TEST_ITEM_ID = "test-item-789"

# Test timestamps
TEST_TIMESTAMP = "2024-01-01T00:00:00Z"
```

## Assertions Best Practices

### Be Specific
```python
# Good: Specific assertions
assert data["name"] == "Expected Name"
assert data["resourceId"] is not None
assert isinstance(data["createdAt"], str)

# Bad: Too generic
assert data
assert "name" in data
```

### Test Error Messages
```python
# Good: Verify error details
assert response.status_code == 400
error = response.json()
assert error["detail"] == "Invalid post ID format"

# Bad: Only check status code
assert response.status_code == 400
```

### Test Side Effects
```python
# Good: Verify state changes
response = client.post("/api/resources", json=resource_data)
assert response.status_code == 200

# Verify resource was actually created
get_response = client.get(f"/api/resources/{response.json()['resourceId']}")
assert get_response.status_code == 200
```

## Session Testing Checklist

Before completing any session:

- [ ] Session plan reviewed and test objectives confirmed
- [ ] E2E test written before implementation
- [ ] Test initially fails (proves it tests something)
- [ ] Test uses skeleton mock data structure
- [ ] All success cases tested for current endpoint
- [ ] All error cases tested for current endpoint
- [ ] Authentication tested
- [ ] Validation tested
- [ ] All E2E tests passing for current endpoint
- [ ] Unit tests added for complex business logic
- [ ] Test coverage adequate for new code
- [ ] Tests are maintainable and readable
- [ ] Session summary documents test results

## Session Testing Anti-Patterns

Do NOT:
- Skip session plan review
- Write implementation before test
- Skip test because "it's simple"
- Test implementation details instead of behavior
- Use sleep() instead of proper async handling
- Share state between tests
- Forget to test error cases
- Test only happy path
- Commit code with failing tests
- Skip tests during "rapid development"
- Test endpoints from other sessions
- Skip session test documentation