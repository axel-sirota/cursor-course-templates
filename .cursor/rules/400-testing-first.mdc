---
description: Session-based test-driven development patterns for E2E and unit tests
globs: ["tests/**", "**/*test*.py", "plan/sessions/**"]
alwaysApply: false
---

# Session-Based Testing First: Test-Driven Development

## Purpose
Enforce strict test-driven development within each session where E2E tests are written before implementation, tests drive design decisions, and all tests must pass before session completion.

## Session TDD Core Principle

RED → GREEN → REFACTOR (per session)

1. RED: Write test that fails (at session start)
2. GREEN: Implement minimum code to pass test (during session)
3. REFACTOR: Improve code while keeping tests green (before session end)

## Session Testing Context

Each session follows TDD principles:
- Session N: Write E2E tests for current endpoint
- Session N: Implement endpoint to make tests pass
- Session N: Refactor while keeping tests green
- Session N: Document test results in session summary

## E2E Testing Patterns

### Test Structure
Every endpoint test follows this structure:

```python
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_endpoint_success_case():
    """Test successful endpoint execution"""
    # Arrange: Setup test data
    # Act: Make request
    # Assert: Verify response
    pass

def test_endpoint_error_case():
    """Test error handling"""
    pass

def test_endpoint_validation():
    """Test input validation"""
    pass

def test_endpoint_authentication():
    """Test authentication requirements"""
    pass
```

### Using Skeleton Mock Data
Phase 0 skeleton provides expected output structure.

**Step 1: Capture mock response**
```python
# From Phase 0 skeleton
POST /posts returns:
{
    "postId": "mock-123",
    "title": "Mock Title",
    "content": "Mock content",
    "authorId": "mock-author",
    "createdAt": "2024-01-01T00:00:00Z"
}
```

**Step 2: Write test using structure**
```python
def test_create_post():
    """Session 2: Phase 1 - Create post with real implementation"""
    response = client.post("/api/posts", json={
        "title": "Test Post",
        "content": "Test content",
        "authorId": "test-author-123"
    }, headers={"Authorization": f"Bearer {test_token}"})
    
    # Verify structure matches skeleton
    assert response.status_code == 200
    data = response.json()
    
    # Check all fields present
    assert "postId" in data
    assert "title" in data
    assert "content" in data
    assert "authorId" in data
    assert "createdAt" in data
    
    # Verify data correctness
    assert data["title"] == "Test Post"
    assert data["content"] == "Test content"
    
    # Verify dynamic fields
    assert data["postId"] != "mock-123"  # Should be real ID
    assert data["createdAt"] != "2024-01-01T00:00:00Z"  # Should be actual timestamp
```

### Test Fixtures
Create reusable test fixtures in conftest.py:

```python
import pytest
from fastapi.testclient import TestClient
from app.main import app

@pytest.fixture
def client():
    """Test client fixture"""
    return TestClient(app)

@pytest.fixture
def auth_token():
    """Authentication token fixture"""
    # Create test user and get token
    response = client.post("/api/auth/register", json={
        "email": f"test-{uuid.uuid4()}@example.com",
        "password": "testpass123",
        "fullName": "Test User"
    })
    return response.json()["accessToken"]

@pytest.fixture
def auth_headers(auth_token):
    """Authorization headers fixture"""
    return {"Authorization": f"Bearer {auth_token}"}

@pytest.fixture
def test_post(client, auth_headers):
    """Create a test post fixture"""
    response = client.post("/api/posts", json={
        "title": "Test Post",
        "content": "Test content",
        "authorId": "test-author"
    }, headers=auth_headers)
    return response.json()
```

### Testing Patterns by HTTP Method

**POST Endpoints:**
```python
def test_create_resource(client, auth_headers):
    """Test resource creation"""
    response = client.post("/api/posts", json={
        "title": "New Post",
        "content": "Content"
    }, headers=auth_headers)
    
    assert response.status_code == 200
    data = response.json()
    assert data["postId"] is not None
    assert data["title"] == "New Post"

def test_create_resource_validation(client, auth_headers):
    """Test validation errors"""
    response = client.post("/api/posts", json={
        "title": ""  # Invalid: empty title
    }, headers=auth_headers)
    
    assert response.status_code == 422
    
def test_create_resource_unauthorized(client):
    """Test authentication requirement"""
    response = client.post("/api/posts", json={
        "title": "Post"
    })
    
    assert response.status_code == 401
```

**GET Endpoints:**
```python
def test_get_resource(client, auth_headers, test_post):
    """Test resource retrieval"""
    post_id = test_post["postId"]
    response = client.get(f"/api/posts/{post_id}", headers=auth_headers)
    
    assert response.status_code == 200
    data = response.json()
    assert data["postId"] == post_id

def test_get_resource_not_found(client, auth_headers):
    """Test 404 error"""
    response = client.get("/api/posts/nonexistent", headers=auth_headers)
    assert response.status_code == 404
```

**PUT/PATCH Endpoints:**
```python
def test_update_resource(client, auth_headers, test_post):
    """Test resource update"""
    post_id = test_post["postId"]
    response = client.put(f"/api/posts/{post_id}", json={
        "title": "Updated Title"
    }, headers=auth_headers)
    
    assert response.status_code == 200
    data = response.json()
    assert data["title"] == "Updated Title"
```

**DELETE Endpoints:**
```python
def test_delete_resource(client, auth_headers, test_post):
    """Test resource deletion"""
    post_id = test_post["postId"]
    response = client.delete(f"/api/posts/{post_id}", headers=auth_headers)
    
    assert response.status_code == 204
    
    # Verify deletion
    get_response = client.get(f"/api/posts/{post_id}", headers=auth_headers)
    assert get_response.status_code == 404
```

## Unit Testing Patterns

Unit tests are written AFTER E2E tests pass.

### Service Layer Tests
Mock repositories to test business logic:

```python
from unittest.mock import Mock, AsyncMock
import pytest
from app.modules.posts.services.post_service import PostService
from app.modules.posts.models import Post, PostCreate

class TestPostService:
    def setup_method(self):
        """Setup test fixtures"""
        self.mock_repo = Mock()
        self.mock_repo.create = AsyncMock()
        self.service = PostService()
        self.service.post_repo = self.mock_repo
    
    @pytest.mark.asyncio
    async def test_create_post_success(self):
        """Test successful post creation"""
        # Arrange
        post_data = PostCreate(
            title="Test",
            content="Content",
            author_id="author-123"
        )
        expected_post = Post(
            id="post-123",
            title="Test",
            content="Content",
            author_id="author-123",
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        self.mock_repo.create.return_value = expected_post
        
        # Act
        result = await self.service.create_post(post_data)
        
        # Assert
        assert result.id == "post-123"
        assert result.title == "Test"
        self.mock_repo.create.assert_called_once_with(post_data)
    
    @pytest.mark.asyncio
    async def test_create_post_repository_error(self):
        """Test error handling"""
        post_data = PostCreate(title="Test", content="Content", author_id="author-123")
        self.mock_repo.create.side_effect = Exception("Database error")
        
        with pytest.raises(Exception, match="Database error"):
            await self.service.create_post(post_data)
```

## Test Organization

```
tests/
├── api/                    # E2E tests for API endpoints
│   ├── test_health.py
│   ├── test_auth.py
│   └── test_posts.py
├── modules/                # Unit tests for business logic
│   └── posts/
│       ├── test_post_service.py
│       └── test_post_models.py
└── conftest.py            # Shared fixtures
```

## Session Test Execution Strategy

### Session Development (TDD Cycle)
```bash
# Run specific test while implementing in current session
pytest tests/api/test_posts.py::test_create_post -v

# Watch mode (if using pytest-watch)
ptw tests/api/test_posts.py
```

### Session Completion
```bash
# Run all E2E tests for current session
pytest tests/api/test_posts.py -v

# Run all tests to ensure no regressions
pytest tests/ -v

# Run with coverage for session
pytest tests/ --cov=app --cov-report=html
```

## Test Data Management

### Database State
For E2E tests using real database:
- Use unique identifiers (UUID) to avoid conflicts
- Clean up test data in fixtures if needed
- Consider using test database separate from development

### Mock Data Consistency
Use consistent patterns:
```python
# Test IDs
TEST_USER_ID = "test-user-123"
TEST_POST_ID = "test-post-456"
TEST_COMMENT_ID = "test-comment-789"

# Test timestamps
TEST_TIMESTAMP = "2024-01-01T00:00:00Z"
```

## Assertions Best Practices

### Be Specific
```python
# Good: Specific assertions
assert data["title"] == "Expected Title"
assert data["postId"] is not None
assert isinstance(data["createdAt"], str)

# Bad: Too generic
assert data
assert "title" in data
```

### Test Error Messages
```python
# Good: Verify error details
assert response.status_code == 400
error = response.json()
assert error["detail"] == "Invalid post ID format"

# Bad: Only check status code
assert response.status_code == 400
```

### Test Side Effects
```python
# Good: Verify state changes
response = client.post("/api/posts", json=post_data)
assert response.status_code == 200

# Verify post was actually created
get_response = client.get(f"/api/posts/{response.json()['postId']}")
assert get_response.status_code == 200
```

## Session Testing Checklist

Before completing any session:

- [ ] Session plan reviewed and test objectives confirmed
- [ ] E2E test written before implementation
- [ ] Test initially fails (proves it tests something)
- [ ] Test uses skeleton mock data structure
- [ ] All success cases tested for current endpoint
- [ ] All error cases tested for current endpoint
- [ ] Authentication tested
- [ ] Validation tested
- [ ] All E2E tests passing for current endpoint
- [ ] Unit tests added for complex business logic
- [ ] Test coverage adequate for new code
- [ ] Tests are maintainable and readable
- [ ] Session summary documents test results

## Session Testing Anti-Patterns

Do NOT:
- Skip session plan review
- Write implementation before test
- Skip test because "it's simple"
- Test implementation details instead of behavior
- Use sleep() instead of proper async handling
- Share state between tests
- Forget to test error cases
- Test only happy path
- Commit code with failing tests
- Skip tests during "rapid development"
- Test endpoints from other sessions
- Skip session test documentation