---
description: Session N: Phase M endpoint implementation with database integration
globs: ["app/modules/**", "app/api/**", "tests/**", "plan/sessions/**"]
alwaysApply: false
---

# Session N: Phase M Endpoint Implementation

## Purpose
Execute individual session to implement one endpoint per session following strict test-driven development. Each session transforms one mock endpoint into a fully functional implementation with database integration and passing E2E tests.

## Session Prerequisites
- Previous session completed successfully
- Session plan reviewed (plan/sessions/session-N-phase-M.md)
- Phase 0 skeleton with all mock endpoints working
- OpenAPI specification available
- Database environment ready

## Session Selection

Choose next session based on plan/sessions/ folder:
1. Review plan/sessions/session-N-phase-M.md
2. Check dependencies from previous sessions
3. Confirm prerequisites are met
4. Follow session plan objectives

Example session progression:
- Session 2: Phase 1 (POST /resources) - create resources
- Session 3: Phase 2 (GET /resources/{id}) - read single resource  
- Session 4: Phase 3 (GET /resources) - list resources
- Session 5: Phase 4 (POST /resources/{id}/items) - create items
- Session 6: Phase 5 (GET /resources/{id}/items) - read items

## Session Execution Steps

### 1. Session Initialization
Review session plan and document current session:
```
Session N: Phase M ([HTTP Method] [Endpoint Path])
Goal: [One sentence description from session plan]
Dependencies: [List previous sessions required]
Estimated time: [From session plan]
Session Plan: plan/sessions/session-N-phase-M.md
```

### 2. E2E Test First (MUST BE FIRST)
Reference 400-testing-first.mdc for detailed testing rules.

Write test using skeleton's mock data as expected output:
```python
def test_create_resource():
    """Session 2: Phase 1 - POST /resources implementation"""
    response = client.post("/api/resources", json={
        "name": "Test Resource",
        "description": "Test description",
        "ownerId": "test-owner"
    }, headers={"Authorization": f"Bearer {token}"})
    
    assert response.status_code == 200
    data = response.json()
    assert data["name"] == "Test Resource"
    assert "resourceId" in data
    assert "createdAt" in data
```

Run test - it MUST fail with mock data.

### 3. Database Migration
Reference vibe_database.md for migration patterns.

Create migration following naming convention:
```
alembic/versions/
└── 20240101000000_create_resources_table.py
```

Migration must include:
- Table creation with proper columns
- Primary key (UUID with default)
- Foreign keys (if applicable)
- Timestamps (created_at, updated_at)
- Indexes for common queries
- NOT NULL constraints where appropriate

Apply migration locally:
```bash
alembic upgrade head
```

### 4. Domain Models
Reference vibe_database.md for layered model architecture.

Create in app/modules/{module}/models/domain_models.py:

**Base Model (business fields only):**
```python
class ResourceBase(BaseModel):
    """Base Resource model with business fields only"""
    name: str = Field(..., description="Resource name")
    description: str = Field(..., description="Resource description")
    owner_id: str = Field(..., description="Owner identifier")
    
    class Config:
        from_attributes = True
```

**Full Model (includes database metadata):**
```python
class Resource(ResourceBase):
    """Full Resource model with all database fields"""
    id: str = Field(..., description="Unique resource identifier")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    
    class Config:
        from_attributes = True
        json_encoders = {
            datetime: lambda v: v.isoformat(),
        }
```

**Operation Models:**
```python
class ResourceCreate(ResourceBase):
    """Resource creation model"""
    pass

class ResourceUpdate(BaseModel):
    """Resource update model (only updatable fields)"""
    name: Optional[str] = None
    description: Optional[str] = None
    
    class Config:
        from_attributes = True
```

### 5. Repository Implementation
Reference vibe_database.md for repository patterns.

Create in app/modules/{module}/repository/repository.py:

**Type-safe mappers:**
```python
class ResourceRepository:
    def __init__(self, db: Session):
        self.db = db
    
    def _row_to_model(self, row: Any) -> Resource:
        """Convert database row to Resource model"""
        return Resource(
            id=str(row.id),
            name=row.name,
            description=row.description,
            owner_id=row.owner_id,
            created_at=row.created_at,
            updated_at=row.updated_at
        )
    
    def _create_to_orm(self, resource: ResourceCreate) -> Dict[str, Any]:
        """Convert ResourceCreate to ORM format"""
        return {
            "name": resource.name,
            "description": resource.description,
            "owner_id": resource.owner_id
        }
```

**CRUD methods:**
Implement only methods needed for current endpoint:
- create() for POST endpoints
- get_by_id() for GET /{id} endpoints
- get_all() for GET list endpoints
- update() for PUT/PATCH endpoints
- delete() for DELETE endpoints

### 6. Service Layer
Create in app/modules/{module}/services/{module}_service.py:

```python
class ResourceService:
    """Service for Resource operations"""
    
    def __init__(self, db: Session):
        self.resource_repo = ResourceRepository(db)
    
    async def create_resource(self, resource_data: ResourceCreate) -> Resource:
        """Create a new resource
        
        Args:
            resource_data: Resource creation data
            
        Returns:
            Created resource with all fields
            
        Raises:
            Exception: If creation fails
        """
        try:
            return await self.resource_repo.create(resource_data)
        except Exception as e:
            logger.error(f"Error creating resource: {e}")
            raise
```

### 7. Processor Replacement
Reference 500-implementation.mdc for replacement patterns.

Replace mock implementation in API endpoint:
```python
# Before (Phase 0 mock)
@router.post("/resources", response_model=ResourceResponse)
async def create_resource(request: CreateResourceRequest):
    return ResourceResponse(resourceId="mock-123", ...)

# After (Phase 1 real)
@router.post("/resources", response_model=ResourceResponse)
async def create_resource(
    request: CreateResourceRequest,
    current_user: dict = Depends(require_auth),
    db: Session = Depends(get_db)
):
    """Create a new resource"""
    # Convert API model to domain model
    resource_data = ResourceCreate(
        name=request.name,
        description=request.description,
        owner_id=current_user["user_id"]
    )
    
    # Use service layer
    service = ResourceService(db)
    created_resource = await service.create_resource(resource_data)
    
    # Convert domain model to API response
    return ResourceResponse(
        resourceId=str(created_resource.id),
        name=created_resource.name,
        description=created_resource.description,
        ownerId=created_resource.owner_id,
        createdAt=created_resource.created_at.isoformat()
    )
```

### 8. Test Validation
Run E2E tests - they MUST pass now:
```bash
pytest tests/api/test_resources.py::test_create_resource -v
```

If tests fail:
- Check database connection
- Verify migration applied
- Check data transformation logic
- Review error logs

### 9. Session Code Quality
Before session completion:
```bash
# Lint code
ruff check app/ tests/ --fix

# Format code
black app/ tests/

# Check types
mypy app/

# Run all tests
pytest tests/
```

## Session Completion Checklist

- [ ] Session plan reviewed and objectives confirmed
- [ ] E2E test written and initially failed
- [ ] Database migration created and applied
- [ ] Domain models implemented (layered architecture)
- [ ] Repository with type-safe mappers implemented
- [ ] Service layer created
- [ ] API endpoint updated with real implementation
- [ ] E2E tests passing
- [ ] Linting passed (ruff)
- [ ] Code formatted with Black
- [ ] Type checking passed (mypy)
- [ ] Type hints added
- [ ] Docstrings added
- [ ] Error handling implemented
- [ ] Logging added
- [ ] Session summary generated

## Session Shared Libraries

Document any shared code created in session summary:
- New repositories available for other endpoints
- New services that can be reused
- New models that represent core entities
- New utilities or helpers

## Session Completion Response

When session is complete, respond with:

```
Session N Complete: Phase M ([METHOD] [ENDPOINT])

Implemented:
- [Specific endpoint] with real database integration
- Database migration: [migration file]
- Domain models: [model files]
- Repository: [repository file]
- Service layer: [service file]
- API endpoint: [endpoint file]

Tests:
- E2E tests passing: [test file]
- All tests passing: YES/NO

Shared Libraries Created:
- [Repository] - available for future sessions
- [Service] - available for future sessions
- [Models] - available for future sessions

Session Summary:
- Generated plan/sessions/session-N-summary.md
- Documented implementation details
- Listed shared libraries created
- Noted dependencies for next session

Next Session:
- Review plan/sessions/session-N+1-phase-M+1.md for next phase
- When ready, say "Start Session N+1" to begin next implementation

DO NOT proceed to Session N+1 automatically.
```

## Session Transition Documentation

Generate plan/sessions/session-N-summary.md including:
- What was implemented in this session
- Tests that now pass
- Shared libraries created
- Dependencies for next session
- Known limitations
- Performance considerations
- Prerequisites for Session N+1

## Anti-Patterns to Avoid

Do NOT:
- Skip session plan review
- Skip E2E test writing
- Implement without failing test first
- Use single model for all operations
- Put business logic in API endpoints
- Access repository directly from API
- Skip error handling
- Forget to document shared libraries
- Move to next session with failing tests
- Implement more than one endpoint per session
- Skip session summary documentation
- Automatically start next session