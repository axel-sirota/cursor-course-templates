---
description: Session N: Phase M endpoint implementation with database integration
globs: ["app/modules/**", "app/api/**", "tests/**", "plan/sessions/**"]
alwaysApply: false
---

# Session N: Phase M Endpoint Implementation

## Purpose
Execute individual session to implement one endpoint per session following strict test-driven development. Each session transforms one mock endpoint into a fully functional implementation with database integration and passing E2E tests.

## Session Prerequisites
- Previous session completed successfully
- Session plan reviewed (plan/sessions/session-N-phase-M.md)
- Phase 0 skeleton with all mock endpoints working
- OpenAPI specification available
- Database environment ready

## Session Selection

Choose next session based on plan/sessions/ folder:
1. Review plan/sessions/session-N-phase-M.md
2. Check dependencies from previous sessions
3. Confirm prerequisites are met
4. Follow session plan objectives

Example session progression:
- Session 2: Phase 1 (POST /posts) - create posts
- Session 3: Phase 2 (GET /posts/{id}) - read single post  
- Session 4: Phase 3 (GET /posts) - list posts
- Session 5: Phase 4 (POST /posts/{id}/comments) - create comments
- Session 6: Phase 5 (GET /posts/{id}/comments) - read comments

## Session Execution Steps

### 1. Session Initialization
Review session plan and document current session:
```
Session N: Phase M ([HTTP Method] [Endpoint Path])
Goal: [One sentence description from session plan]
Dependencies: [List previous sessions required]
Estimated time: [From session plan]
Session Plan: plan/sessions/session-N-phase-M.md
```

### 2. E2E Test First (MUST BE FIRST)
Reference 400-testing-first.mdc for detailed testing rules.

Write test using skeleton's mock data as expected output:
```python
def test_create_post():
    """Session 2: Phase 1 - POST /posts implementation"""
    response = client.post("/api/posts", json={
        "title": "Test Post",
        "content": "Test content",
        "authorId": "test-author"
    }, headers={"Authorization": f"Bearer {token}"})
    
    assert response.status_code == 200
    data = response.json()
    assert data["title"] == "Test Post"
    assert "postId" in data
    assert "createdAt" in data
```

Run test - it MUST fail with mock data.

### 3. Database Migration
Reference vibe_database.md for migration patterns.

Create migration following naming convention:
```
database/develop/supabase/migrations/
└── 20240101000000_create_posts_table.sql
```

Migration must include:
- Table creation with proper columns
- Primary key (UUID with default)
- Foreign keys (if applicable)
- Timestamps (created_at, updated_at)
- Indexes for common queries
- NOT NULL constraints where appropriate

Apply migration locally:
```bash
cd database/develop
supabase db reset
```

### 4. Domain Models
Reference vibe_database.md for layered model architecture.

Create in app/modules/{module}/models/domain_models.py:

**Base Model (business fields only):**
```python
class PostBase(BaseModel):
    """Base Post model with business fields only"""
    title: str = Field(..., description="Post title")
    content: str = Field(..., description="Post content")
    author_id: str = Field(..., description="Author identifier")
    
    class Config:
        from_attributes = True
```

**Full Model (includes database metadata):**
```python
class Post(PostBase):
    """Full Post model with all database fields"""
    id: str = Field(..., description="Unique post identifier")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    
    class Config:
        from_attributes = True
        json_encoders = {
            datetime: lambda v: v.isoformat(),
        }
```

**Operation Models:**
```python
class PostCreate(PostBase):
    """Post creation model"""
    pass

class PostUpdate(BaseModel):
    """Post update model (only updatable fields)"""
    title: Optional[str] = None
    content: Optional[str] = None
    
    class Config:
        from_attributes = True
```

### 5. Repository Implementation
Reference vibe_database.md for repository patterns.

Create in app/modules/{module}/repository/repository.py:

**Type-safe mappers:**
```python
class PostRepository:
    def __init__(self):
        self.table_name = "posts"
    
    def _supabase_to_model(self, row: Dict[str, Any]) -> Post:
        """Convert Supabase row to Post model"""
        return Post(
            id=str(row["id"]),
            title=row["title"],
            content=row["content"],
            author_id=row["author_id"],
            created_at=row["created_at"],
            updated_at=row["updated_at"]
        )
    
    def _modelcreate_to_supabase(self, post: PostCreate) -> Dict[str, Any]:
        """Convert PostCreate to Supabase format"""
        return {
            "title": post.title,
            "content": post.content,
            "author_id": post.author_id
        }
```

**CRUD methods:**
Implement only methods needed for current endpoint:
- create() for POST endpoints
- get_by_id() for GET /{id} endpoints
- get_all() for GET list endpoints
- update() for PUT/PATCH endpoints
- delete() for DELETE endpoints

### 6. Service Layer
Create in app/modules/{module}/services/{module}_service.py:

```python
class PostService:
    """Service for Post operations"""
    
    def __init__(self):
        self.post_repo = PostRepository()
    
    async def create_post(self, post_data: PostCreate) -> Post:
        """Create a new post
        
        Args:
            post_data: Post creation data
            
        Returns:
            Created post with all fields
            
        Raises:
            Exception: If creation fails
        """
        try:
            return await self.post_repo.create(post_data)
        except Exception as e:
            logger.error(f"Error creating post: {e}")
            raise
```

### 7. Processor Replacement
Reference 500-implementation.mdc for replacement patterns.

Replace mock implementation in API endpoint:
```python
# Before (Phase 0 mock)
@router.post("/posts", response_model=PostResponse)
async def create_post(request: CreatePostRequest):
    return PostResponse(postId="mock-123", ...)

# After (Phase 1 real)
@router.post("/posts", response_model=PostResponse)
async def create_post(
    request: CreatePostRequest,
    current_user: dict = Depends(require_auth)
):
    """Create a new blog post"""
    # Convert API model to domain model
    post_data = PostCreate(
        title=request.title,
        content=request.content,
        author_id=current_user["user_id"]
    )
    
    # Use service layer
    service = PostService()
    created_post = await service.create_post(post_data)
    
    # Convert domain model to API response
    return PostResponse(
        postId=str(created_post.id),
        title=created_post.title,
        content=created_post.content,
        authorId=created_post.author_id,
        createdAt=created_post.created_at.isoformat()
    )
```

### 8. Test Validation
Run E2E tests - they MUST pass now:
```bash
pytest tests/api/test_posts.py::test_create_post -v
```

If tests fail:
- Check database connection
- Verify migration applied
- Check data transformation logic
- Review error logs

### 9. Session Code Quality
Before session completion:
```bash
# Format code
black app/ tests/

# Check types
mypy app/modules/posts/

# Run all tests
pytest tests/
```

## Session Completion Checklist

- [ ] Session plan reviewed and objectives confirmed
- [ ] E2E test written and initially failed
- [ ] Database migration created and applied
- [ ] Domain models implemented (layered architecture)
- [ ] Repository with type-safe mappers implemented
- [ ] Service layer created
- [ ] API endpoint updated with real implementation
- [ ] E2E tests passing
- [ ] Code formatted with Black
- [ ] Type hints added
- [ ] Docstrings added
- [ ] Error handling implemented
- [ ] Logging added
- [ ] Session summary generated

## Session Shared Libraries

Document any shared code created in session summary:
- New repositories available for other endpoints
- New services that can be reused
- New models that represent core entities
- New utilities or helpers

## Session Completion Response

When session is complete, respond with:

```
Session N Complete: Phase M ([METHOD] [ENDPOINT])

Implemented:
- [Specific endpoint] with real database integration
- Database migration: [migration file]
- Domain models: [model files]
- Repository: [repository file]
- Service layer: [service file]
- API endpoint: [endpoint file]

Tests:
- E2E tests passing: [test file]
- All tests passing: YES/NO

Shared Libraries Created:
- [Repository] - available for future sessions
- [Service] - available for future sessions
- [Models] - available for future sessions

Session Summary:
- Generated plan/sessions/session-N-summary.md
- Documented implementation details
- Listed shared libraries created
- Noted dependencies for next session

Next Session:
- Review plan/sessions/session-N+1-phase-M+1.md for next phase
- When ready, say "Start Session N+1" to begin next implementation

DO NOT proceed to Session N+1 automatically.
```

## Session Transition Documentation

Generate plan/sessions/session-N-summary.md including:
- What was implemented in this session
- Tests that now pass
- Shared libraries created
- Dependencies for next session
- Known limitations
- Performance considerations
- Prerequisites for Session N+1

## Anti-Patterns to Avoid

Do NOT:
- Skip session plan review
- Skip E2E test writing
- Implement without failing test first
- Use single model for all operations
- Put business logic in API endpoints
- Access repository directly from API
- Skip error handling
- Forget to document shared libraries
- Move to next session with failing tests
- Implement more than one endpoint per session
- Skip session summary documentation
- Automatically start next session